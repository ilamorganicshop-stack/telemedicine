{% extends 'medical/base.html' %}

{% block title %}Video Call - Dr. {{ appointment.doctor.first_name }} {{ appointment.doctor.last_name }} & {{ appointment.patient.first_name }} {{ appointment.patient.last_name }}{% endblock %}

{% block medical_nav %}{% endblock %}

{% block extra_css %}
<style>
    :root {
        --call-bg: #0d1117;
        --panel-bg: #161b22;
        --surface: #0b0f14;
        --surface-soft: rgba(255, 255, 255, 0.06);
        --text-main: #e6edf3;
        --text-muted: #9ba7b4;
        --accent: #4f8cff;
        --danger: #ef4444;
        --ring: rgba(79, 140, 255, 0.25);
    }

    .call-shell {
        min-height: calc(100vh - 6rem);
        color: var(--text-main);
    }

    .call-frame {
        background: linear-gradient(180deg, #0e131a 0%, #0b1016 100%);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 18px;
        padding: 14px;
        box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
    }

    .call-topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding: 8px 4px;
    }

    .call-back {
        color: #c0c9d4;
        font-size: 13px;
        font-weight: 500;
        text-decoration: none;
        transition: color 0.2s ease;
    }

    .call-back:hover {
        color: #ffffff;
    }

    .call-peer {
        font-size: 13px;
        color: var(--text-muted);
    }

    .video-stage {
        position: relative;
        width: 100%;
        height: min(76vh, 820px);
        border-radius: 16px;
        overflow: hidden;
        background: #000;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .remote-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #000;
    }

    .waiting-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        pointer-events: none;
        z-index: 8;
        background: radial-gradient(circle at center, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.55));
    }

    .waiting-text {
        color: rgba(230, 237, 243, 0.8);
        font-size: clamp(16px, 2.2vw, 22px);
        font-weight: 500;
        letter-spacing: 0.01em;
        text-shadow: 0 2px 16px rgba(0, 0, 0, 0.35);
    }

    .waiting-status {
        margin-top: 10px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: rgba(210, 223, 236, 0.9);
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 0.01em;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #60a5fa;
        box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.5);
        animation: statusPulse 1.8s infinite;
    }

    .status-dot.steady {
        background: #22c55e;
        box-shadow: none;
        animation: none;
    }

    .status-dot.warning {
        background: #f59e0b;
    }

    @keyframes statusPulse {
        0% { box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.5); }
        70% { box-shadow: 0 0 0 10px rgba(96, 165, 250, 0); }
        100% { box-shadow: 0 0 0 0 rgba(96, 165, 250, 0); }
    }

    .local-video-wrap {
        position: absolute;
        top: 20px;
        right: 20px;
        width: clamp(160px, 20vw, 248px);
        aspect-ratio: 16 / 10;
        border-radius: 14px;
        overflow: hidden;
        z-index: 12;
        background: #0f141b;
        box-shadow: 0 14px 34px rgba(0, 0, 0, 0.42);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .local-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #111;
    }

    .self-badge {
        position: absolute;
        left: 8px;
        bottom: 8px;
        padding: 3px 8px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        color: #dbe6f1;
        background: rgba(0, 0, 0, 0.56);
        backdrop-filter: blur(5px);
    }

    .controls-row {
        position: absolute;
        left: 50%;
        bottom: 22px;
        transform: translateX(-50%);
        display: flex;
        gap: 14px;
        padding: 12px 16px;
        border-radius: 999px;
        z-index: 15;
        background: rgba(16, 21, 29, 0.82);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.38);
        backdrop-filter: blur(8px);
    }

    .control-btn {
        width: 52px;
        height: 52px;
        border: none;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #f4f8fc;
        background: var(--surface-soft);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        cursor: pointer;
        transition: transform 0.18s ease, background-color 0.2s ease;
    }

    .control-btn:hover {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.14);
    }

    .control-btn:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--ring);
    }

    .control-btn.is-off {
        background: rgba(239, 68, 68, 0.9);
    }

    .control-btn.end-call {
        background: var(--danger);
    }

    .control-btn.end-call:hover {
        background: #dc2626;
    }

    @media (max-width: 640px) {
        .call-frame {
            border-radius: 14px;
            padding: 10px;
        }

        .video-stage {
            height: min(74vh, 680px);
            border-radius: 12px;
        }

        .local-video-wrap {
            top: 12px;
            right: 12px;
            width: 140px;
            border-radius: 11px;
        }

        .controls-row {
            bottom: 14px;
            padding: 10px 12px;
            gap: 10px;
        }

        .control-btn {
            width: 46px;
            height: 46px;
        }
    }
</style>
{% endblock %}

{% block medical_content %}
<div class="call-shell">
    <div class="call-frame">
        <div class="call-topbar">
            <a href="{% url 'medical:chat' appointment.id %}" class="call-back">Back to Chat</a>
            <p class="call-peer">
                {% if user_type == 'doctor' %}
                    Patient: {{ appointment.patient.first_name }} {{ appointment.patient.last_name }}
                {% else %}
                    Doctor: Dr. {{ appointment.doctor.first_name }} {{ appointment.doctor.last_name }}
                {% endif %}
            </p>
        </div>

        <div class="video-stage" id="videoContainer">
            <video id="remoteVideo" class="remote-video" autoplay playsinline></video>

            <div class="waiting-overlay" id="waitingOverlay">
                <div>
                    <p class="waiting-text" id="waitingText">Waiting for participant to join.</p>
                    <div class="waiting-status" id="waitingStatus" aria-live="polite">
                        <span class="status-dot" id="waitingStatusDot"></span>
                        <span id="waitingStatusText">Connecting...</span>
                    </div>
                </div>
            </div>

            <div class="local-video-wrap">
                <video id="localVideo" class="local-video" autoplay playsinline muted></video>
                <span class="self-badge">You</span>
            </div>

            <div class="controls-row" aria-label="Call controls">
                <button class="control-btn" id="muteBtn" type="button" onclick="toggleMute()" title="Mute or unmute microphone">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M12 14a3 3 0 0 0 3-3V5a3 3 0 0 0-6 0v6a3 3 0 0 0 3 3Zm5-3a5 5 0 1 1-10 0H5a7 7 0 0 0 6 6.92V21h2v-3.08A7 7 0 0 0 19 11h-2Z"/>
                    </svg>
                </button>

                <button class="control-btn" id="videoBtn" type="button" onclick="toggleVideo()" title="Turn camera on or off">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4v-11l-4 4Z"/>
                    </svg>
                </button>

                <button class="control-btn end-call" type="button" onclick="endCall()" title="End call">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M12 9c-4.54 0-8.66 1.78-11.71 4.67a1 1 0 0 0 0 1.42l2.48 2.48a1 1 0 0 0 1.41 0c.79-.74 1.68-1.36 2.66-1.85a1 1 0 0 0 .56-.9v-2.1a15.3 15.3 0 0 1 9.2 0v2.1a1 1 0 0 0 .56.9c.98.49 1.88 1.11 2.67 1.85a1 1 0 0 0 1.4 0l2.48-2.48a1 1 0 0 0 0-1.42C20.66 10.78 16.54 9 12 9Z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const webrtcConfig = JSON.parse('{{ webrtc_config|safe }}');
    const roomId = '{{ room_id }}';
    const userType = '{{ user_type }}';
    const appointmentId = '{{ appointment.id }}';

    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let websocket = null;
    let isMuted = false;
    let isVideoOff = false;
    let isEndingCall = false;
    let offerRetryTimer = null;
    let isCreatingOffer = false;

    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const wsUrl = `${wsScheme}://${window.location.host}/ws/video-call/${roomId}/`;

    const iceServers = {
        iceServers: [
            ...webrtcConfig.stun_servers.map((url) => ({ urls: url })),
            ...webrtcConfig.turn_servers.map((server) => ({
                urls: server.urls,
                username: server.username,
                credential: server.credential,
            })),
        ],
    };

    function setWaitingState(isWaiting, messageText = 'Waiting for participant to join.') {
        const overlay = document.getElementById('waitingOverlay');
        const text = document.getElementById('waitingText');
        if (!overlay) return;
        overlay.style.display = isWaiting ? 'flex' : 'none';
        if (text) {
            text.textContent = messageText;
        }
    }

    function setConnectingStatus(messageText = 'Connecting...', state = 'connecting') {
        const statusText = document.getElementById('waitingStatusText');
        const statusDot = document.getElementById('waitingStatusDot');

        if (statusText) {
            statusText.textContent = messageText;
        }

        if (statusDot) {
            statusDot.classList.remove('steady', 'warning');
            if (state === 'connected') {
                statusDot.classList.add('steady');
            } else if (state === 'warning') {
                statusDot.classList.add('warning');
            }
        }
    }

    function initializeWebSocket() {
        websocket = new WebSocket(wsUrl);

        websocket.onopen = function () {
            setConnectingStatus('Connected to signaling server.', 'connected');
            websocket.send(
                JSON.stringify({
                    type: 'join',
                    user_type: userType,
                    user_name: userType === 'doctor' ? 'Doctor' : 'Patient',
                })
            );
            if (userType === 'doctor') {
                startOfferRetry();
                createOfferIfPossible();
            }
        };

        websocket.onmessage = function (event) {
            const data = JSON.parse(event.data);
            handleSignalingMessage(data);
        };

        websocket.onerror = function (error) {
            console.error('WebSocket error:', error);
            setConnectingStatus('Connection issue. Retrying...', 'warning');
        };

        websocket.onclose = function () {
            setConnectingStatus('Reconnecting...', 'warning');
            if (!isEndingCall) {
                setTimeout(initializeWebSocket, 3000);
            }
        };
    }

    function handleSignalingMessage(data) {
        switch (data.type) {
            case 'offer':
                handleOffer(data.offer);
                break;
            case 'answer':
                handleAnswer(data.answer);
                break;
            case 'ice-candidate':
                handleIceCandidate(data.candidate);
                break;
            case 'user-joined':
                if (data.user_type !== userType) {
                    setConnectingStatus('Participant detected. Connecting media...', 'connecting');
                    setWaitingState(true, 'Connecting call...');
                    if (userType === 'doctor') {
                        createOfferIfPossible();
                    }
                }
                break;
            case 'user-left':
                if (data.user_type !== userType) {
                    setConnectingStatus('Participant left. Waiting to reconnect...', 'warning');
                    setWaitingState(true);
                    if (userType === 'doctor') {
                        startOfferRetry();
                    }
                }
                break;
            default:
                break;
        }
    }

    async function initializeWebRTC() {
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    facingMode: 'user',
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100,
                },
            });

            const localVideo = document.getElementById('localVideo');
            localVideo.srcObject = localStream;

            createPeerConnection();

            localStream.getTracks().forEach((track) => {
                peerConnection.addTrack(track, localStream);
            });

            initializeWebSocket();
        } catch (error) {
            console.error('Error accessing media devices:', error);
            alert('Could not access camera or microphone. Please check permissions.');
        }
    }

    function createPeerConnection() {
        peerConnection = new RTCPeerConnection(iceServers);

        peerConnection.ontrack = function (event) {
            if (event.streams && event.streams[0]) {
                remoteStream = event.streams[0];
                const remoteVideo = document.getElementById('remoteVideo');
                remoteVideo.srcObject = remoteStream;
                setWaitingState(false);
                setConnectingStatus('Connected', 'connected');
                if (userType === 'doctor') {
                    stopOfferRetry();
                }
            }
        };

        peerConnection.onicecandidate = function (event) {
            if (event.candidate && websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(
                    JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                    })
                );
            }
        };

        peerConnection.onconnectionstatechange = function () {
            const state = peerConnection.connectionState;
            if (state === 'connected') {
                setWaitingState(false);
                setConnectingStatus('Connected', 'connected');
                if (userType === 'doctor') {
                    stopOfferRetry();
                }
            }
            if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                setWaitingState(true, 'Waiting for participant to rejoin.');
                setConnectingStatus('Reconnecting media...', 'warning');
                if (userType === 'doctor' && !isEndingCall) {
                    startOfferRetry();
                }
            }
        };
    }

    function canCreateOffer() {
        return (
            userType === 'doctor' &&
            peerConnection &&
            websocket &&
            websocket.readyState === WebSocket.OPEN &&
            peerConnection.signalingState === 'stable' &&
            !isCreatingOffer
        );
    }

    function createOfferIfPossible() {
        if (canCreateOffer()) {
            createOffer();
        }
    }

    function startOfferRetry() {
        if (offerRetryTimer || userType !== 'doctor') return;
        offerRetryTimer = setInterval(() => {
            if (remoteStream || isEndingCall) {
                stopOfferRetry();
                return;
            }
            createOfferIfPossible();
        }, 2500);
    }

    function stopOfferRetry() {
        if (!offerRetryTimer) return;
        clearInterval(offerRetryTimer);
        offerRetryTimer = null;
    }

    async function createOffer() {
        if (!canCreateOffer()) return;
        isCreatingOffer = true;
        try {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            websocket.send(
                JSON.stringify({
                    type: 'offer',
                    offer: offer,
                })
            );
        } catch (error) {
            console.error('Error creating offer:', error);
        } finally {
            isCreatingOffer = false;
        }
    }

    async function handleOffer(offer) {
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            websocket.send(
                JSON.stringify({
                    type: 'answer',
                    answer: answer,
                })
            );
        } catch (error) {
            console.error('Error handling offer:', error);
        }
    }

    async function handleAnswer(answer) {
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        } catch (error) {
            console.error('Error handling answer:', error);
        }
    }

    async function handleIceCandidate(candidate) {
        try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
        } catch (error) {
            console.error('Error adding ICE candidate:', error);
        }
    }

    function toggleMute() {
        if (!localStream) return;

        isMuted = !isMuted;
        localStream.getAudioTracks().forEach((track) => {
            track.enabled = !isMuted;
        });

        const muteBtn = document.getElementById('muteBtn');
        muteBtn.classList.toggle('is-off', isMuted);
    }

    function toggleVideo() {
        if (!localStream) return;

        isVideoOff = !isVideoOff;
        localStream.getVideoTracks().forEach((track) => {
            track.enabled = !isVideoOff;
        });

        const videoBtn = document.getElementById('videoBtn');
        videoBtn.classList.toggle('is-off', isVideoOff);
    }

    function endCall() {
        isEndingCall = true;

        if (websocket && websocket.readyState === WebSocket.OPEN) {
            websocket.send(
                JSON.stringify({
                    type: 'leave',
                    user_type: userType,
                    user_name: userType === 'doctor' ? 'Doctor' : 'Patient',
                })
            );
        }

        if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
        }

        if (peerConnection) {
            peerConnection.close();
        }

        if (websocket) {
            websocket.close();
        }

        stopOfferRetry();
        window.location.href = `/medical/appointments/${appointmentId}/video-call/end/`;
    }

    window.addEventListener('beforeunload', function () {
        stopOfferRetry();
        if (websocket) {
            websocket.close();
        }
        if (peerConnection) {
            peerConnection.close();
        }
    });

    document.addEventListener('DOMContentLoaded', function () {
        if (!roomId) {
            setWaitingState(true, 'Call room is not ready yet.');
            setConnectingStatus('Room setup incomplete.', 'warning');
            return;
        }

        setConnectingStatus('Connecting...', 'connecting');

        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.addEventListener('playing', function () {
            setWaitingState(false);
            setConnectingStatus('Connected', 'connected');
        });

        initializeWebRTC();
    });
</script>
{% endblock %}
