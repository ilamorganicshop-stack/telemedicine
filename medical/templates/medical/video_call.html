{% extends 'medical/base.html' %}

{% block title %}Video Call - Dr. {{ appointment.doctor.first_name }} {{ appointment.doctor.last_name }} & {{ appointment.patient.first_name }} {{ appointment.patient.last_name }}{% endblock %}

{% block medical_nav %}{% endblock %}

{% block extra_css %}
<style>
    :root {
        --call-bg: #0d1117;
        --panel-bg: #161b22;
        --surface: #0b0f14;
        --surface-soft: rgba(255, 255, 255, 0.06);
        --text-main: #e6edf3;
        --text-muted: #9ba7b4;
        --accent: #4f8cff;
        --danger: #ef4444;
        --ring: rgba(79, 140, 255, 0.25);
    }

    .call-shell {
        position: fixed;
        inset: 0;
        z-index: 9999;
        min-height: 100vh;
        padding: clamp(8px, 2vw, 20px);
        background: rgba(6, 10, 16, 0.94);
        color: var(--text-main);
    }

    .call-frame {
        background: linear-gradient(180deg, #0e131a 0%, #0b1016 100%);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 18px;
        padding: 14px;
        box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
        height: 100%;
        max-width: 1480px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
    }

    .call-topbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
        padding: 8px 4px;
    }

    .call-back {
        color: #c0c9d4;
        font-size: 13px;
        font-weight: 500;
        text-decoration: none;
        transition: color 0.2s ease;
    }

    .call-back:hover {
        color: #ffffff;
    }

    .call-peer {
        font-size: 13px;
        color: var(--text-muted);
    }

    .video-stage {
        position: relative;
        width: 100%;
        max-width: 600px;
        margin: 0 auto;
        flex: 1;
        min-height: 0;
        height: auto;
        border-radius: 16px;
        overflow: hidden;
        background: #000;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .remote-video {
        width: 100%;
        height: 100%;
        max-height: 85vh;
        aspect-ratio: 9 / 16;
        object-fit: cover;
        background: #000;
    }

    .waiting-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        pointer-events: none;
        z-index: 8;
        background: radial-gradient(circle at center, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.55));
    }

    .waiting-text {
        color: rgba(230, 237, 243, 0.8);
        font-size: clamp(16px, 2.2vw, 22px);
        font-weight: 500;
        letter-spacing: 0.01em;
        text-shadow: 0 2px 16px rgba(0, 0, 0, 0.35);
    }

    .waiting-status {
        margin-top: 10px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: rgba(210, 223, 236, 0.9);
        font-size: 13px;
        font-weight: 500;
        letter-spacing: 0.01em;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #60a5fa;
        box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.5);
        animation: statusPulse 1.8s infinite;
    }

    .status-dot.steady {
        background: #22c55e;
        box-shadow: none;
        animation: none;
    }

    .status-dot.warning {
        background: #f59e0b;
    }

    @keyframes statusPulse {
        0% { box-shadow: 0 0 0 0 rgba(96, 165, 250, 0.5); }
        70% { box-shadow: 0 0 0 10px rgba(96, 165, 250, 0); }
        100% { box-shadow: 0 0 0 0 rgba(96, 165, 250, 0); }
    }

    .local-video-wrap {
        position: absolute;
        top: 12px;
        right: 12px;
        width: clamp(120px, 15vw, 180px);
        aspect-ratio: 9 / 16;
        border-radius: 12px;
        overflow: hidden;
        z-index: 12;
        background: #0f141b;
        box-shadow: 0 14px 34px rgba(0, 0, 0, 0.42);
        border: 1px solid rgba(255, 255, 255, 0.2);
    }

    .local-video {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #111;
    }

    .self-badge {
        position: absolute;
        left: 8px;
        bottom: 8px;
        padding: 3px 8px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        color: #dbe6f1;
        background: rgba(0, 0, 0, 0.56);
        backdrop-filter: blur(5px);
    }

    .controls-row {
        position: absolute;
        left: 50%;
        bottom: 40px;
        transform: translateX(-50%);
        display: flex;
        gap: 14px;
        padding: 12px 16px;
        border-radius: 999px;
        z-index: 15;
        background: rgba(16, 21, 29, 0.82);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 14px 30px rgba(0, 0, 0, 0.38);
        backdrop-filter: blur(8px);
    }

    .control-btn {
        width: 52px;
        height: 52px;
        border: none;
        border-radius: 50%;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #f4f8fc;
        background: var(--surface-soft);
        box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
        cursor: pointer;
        transition: transform 0.18s ease, background-color 0.2s ease;
    }

    .control-btn:hover {
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.14);
    }

    .control-btn:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--ring);
    }

    .control-btn.is-off {
        background: rgba(239, 68, 68, 0.9);
    }

    .control-btn.end-call {
        background: var(--danger);
    }

    .control-btn.end-call:hover {
        background: #dc2626;
    }

    @media (max-width: 640px) {
        .call-shell {
            padding: 0;
            safe-area-inset: 0;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
        }

        .call-frame {
            border-radius: 0;
            border: none;
            padding: 0;
            box-shadow: none;
            height: 100%;
        }
        
        .call-topbar {
            display: none;
        }

        .video-stage {
            border-radius: 0;
            max-width: 100%;
            width: 100%;
            height: 100%;
        }
        
        .remote-video {
            max-height: 90vh;
        }

        .local-video-wrap {
            top: 12px;
            right: 12px;
            width: 140px;
            border-radius: 11px;
        }

        .controls-row {
            bottom: 90px;
            padding: 10px 12px;
            gap: 10px;
        }

        .control-btn {
            width: 46px;
            height: 46px;
        }
    }
</style>
{% endblock %}

{% block medical_content %}
<div class="call-shell">
    <div class="call-frame">
        <div class="call-topbar">
            <a href="{{ return_to }}" class="call-back">Back</a>
            <p class="call-peer">
                {% if user_type == 'doctor' %}
                    Patient: {{ appointment.patient.first_name }} {{ appointment.patient.last_name }}
                {% else %}
                    Doctor: Dr. {{ appointment.doctor.first_name }} {{ appointment.doctor.last_name }}
                {% endif %}
            </p>
        </div>

        <div class="video-stage" id="videoContainer">
            <video id="remoteVideo" class="remote-video" autoplay playsinline></video>

            <div class="waiting-overlay" id="waitingOverlay">
                <div>
                    <p class="waiting-text" id="waitingText">Waiting for participant to join.</p>
                    <div class="waiting-status" id="waitingStatus" aria-live="polite">
                        <span class="status-dot" id="waitingStatusDot"></span>
                        <span id="waitingStatusText">Connecting...</span>
                    </div>
                </div>
            </div>

            <div class="local-video-wrap">
                <video id="localVideo" class="local-video" autoplay playsinline muted></video>
                <span class="self-badge">You</span>
            </div>

            <div class="controls-row" aria-label="Call controls">
                <button class="control-btn" id="muteBtn" type="button" onclick="toggleMute()" title="Mute or unmute microphone">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M12 14a3 3 0 0 0 3-3V5a3 3 0 0 0-6 0v6a3 3 0 0 0 3 3Zm5-3a5 5 0 1 1-10 0H5a7 7 0 0 0 6 6.92V21h2v-3.08A7 7 0 0 0 19 11h-2Z"/>
                    </svg>
                </button>

                <button class="control-btn" id="videoBtn" type="button" onclick="toggleVideo()" title="Turn camera on or off">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M17 10.5V7a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-3.5l4 4v-11l-4 4Z"/>
                    </svg>
                </button>

                <button class="control-btn end-call" type="button" onclick="endCall()" title="End call">
                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                        <path d="M12 9c-4.54 0-8.66 1.78-11.71 4.67a1 1 0 0 0 0 1.42l2.48 2.48a1 1 0 0 0 1.41 0c.79-.74 1.68-1.36 2.66-1.85a1 1 0 0 0 .56-.9v-2.1a15.3 15.3 0 0 1 9.2 0v2.1a1 1 0 0 0 .56.9c.98.49 1.88 1.11 2.67 1.85a1 1 0 0 0 1.4 0l2.48-2.48a1 1 0 0 0 0-1.42C20.66 10.78 16.54 9 12 9Z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const webrtcConfig = JSON.parse('{{ webrtc_config|safe }}');
    const roomId = '{{ room_id }}';
    const userType = '{{ user_type }}';
    const appointmentId = '{{ appointment.id }}';
    const returnTo = '{{ return_to|escapejs }}';

    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let websocket = null;
    let isMuted = false;
    let isVideoOff = false;
    let isEndingCall = false;
    let offerRetryTimer = null;
    let isCreatingOffer = false;
    let iceCandidateQueue = [];
    let vibrationTimer = null;
    let isRinging = false;

    // Debug logging
    console.log('=== Video Call Debug Info ===');
    console.log('Room ID:', roomId);
    console.log('User Type:', userType);
    console.log('Window Location:', window.location.href);
    console.log('Protocol:', window.location.protocol);
    console.log('Host:', window.location.host);
    
    // Fix WebSocket URL for production - use wss for https, ws for http
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    // Use the current host which should work with Defang's deployment
    const wsHost = window.location.host;
    const wsUrl = `${wsScheme}://${wsHost}/ws/video-call/${roomId}/`;
    
    console.log('WebSocket URL:', wsUrl);
    console.log('=============================');

    const iceServers = {
        iceServers: [
            ...webrtcConfig.stun_servers.map((url) => ({ urls: url })),
            ...webrtcConfig.turn_servers.map((server) => ({
                urls: server.urls,
                username: server.username,
                credential: server.credential,
            })),
        ],
    };

    function setWaitingState(isWaiting, messageText = 'Waiting for participant to join.') {
        const overlay = document.getElementById('waitingOverlay');
        const text = document.getElementById('waitingText');
        if (!overlay) return;
        overlay.style.display = isWaiting ? 'flex' : 'none';
        if (text) {
            text.textContent = messageText;
        }
    }

    function setConnectingStatus(messageText = 'Connecting...', state = 'connecting') {
        const statusText = document.getElementById('waitingStatusText');
        const statusDot = document.getElementById('waitingStatusDot');

        if (statusText) {
            statusText.textContent = messageText;
        }

        if (statusDot) {
            statusDot.classList.remove('steady', 'warning');
            if (state === 'connected') {
                statusDot.classList.add('steady');
            } else if (state === 'warning') {
                statusDot.classList.add('warning');
            }
        }
    }

    function startRingVibration() {
        if (!navigator.vibrate || isRinging) return;
        isRinging = true;
        console.log('Starting continuous ring vibration');
        vibrationTimer = setInterval(() => {
            // Ring vibration pattern: vibrate 400ms, pause 200ms, repeat
            navigator.vibrate([400, 200]);
        }, 600);
    }

    function stopRingVibration() {
        if (vibrationTimer) {
            clearInterval(vibrationTimer);
            vibrationTimer = null;
            isRinging = false;
            if (navigator.vibrate) {
                navigator.vibrate(0); // stop any ongoing vibration
            }
            console.log('Stopped ring vibration');
        }
    }

    function initializeWebSocket() {
        console.log('Initializing WebSocket connection...');
        websocket = new WebSocket(wsUrl);

        websocket.onopen = function () {
            console.log('WebSocket connected successfully!');
            console.log('WebSocket readyState:', websocket.readyState);
            console.log('WebSocket URL:', wsUrl);
            setConnectingStatus('Connected to signaling server.', 'connected');
            
            const joinMessage = {
                type: 'join',
                user_type: userType,
                user_name: userType === 'doctor' ? 'Doctor' : 'Patient',
            };
            console.log('Sending join message:', JSON.stringify(joinMessage));
            websocket.send(JSON.stringify(joinMessage));
            console.log('Join message sent as:', userType);
            
            // Don't create offer immediately - wait for patient to join
            if (userType === 'doctor') {
                console.log('Doctor: Starting offer retry mechanism (will create offer when patient joins)');
                startOfferRetry();
            }
        };

        websocket.onmessage = function (event) {
            console.log('WebSocket message received:', event.data);
            try {
                const data = JSON.parse(event.data);
                console.log('Parsed message data:', data);
                handleSignalingMessage(data);
            } catch (error) {
                console.error('Error parsing WebSocket message:', error);
                console.error('Raw message:', event.data);
            }
        };

        websocket.onerror = function (error) {
            console.error('WebSocket error:', error);
            console.error('WebSocket readyState:', websocket.readyState);
            setConnectingStatus('Connection issue. Retrying...', 'warning');
        };

        websocket.onclose = function (event) {
            console.log('WebSocket closed. Code:', event.code, 'Reason:', event.reason);
            setConnectingStatus('Reconnecting...', 'warning');
            if (!isEndingCall) {
                console.log('Attempting to reconnect in 3 seconds...');
                setTimeout(initializeWebSocket, 3000);
            }
        };
    }

    function handleSignalingMessage(data) {
        console.log('Handling signaling message type:', data.type, 'Data:', data);
        switch (data.type) {
            case 'offer':
                console.log('Received offer, handling...');
                handleOffer(data.offer);
                break;
            case 'answer':
                console.log('Received answer, handling...');
                handleAnswer(data.answer);
                break;
            case 'ice-candidate':
                console.log('Received ICE candidate');
                handleIceCandidate(data.candidate);
                break;
            case 'user-joined':
                console.log('User joined:', data.user_type, 'Current user:', userType);
                if (data.user_type !== userType) {
                    console.log('Other participant joined! Starting connection...');
                    setConnectingStatus('Participant detected. Connecting media...', 'connecting');
                    setWaitingState(true, 'Connecting call...');
                    
                    // Start continuous vibration for patient when doctor joins (incoming call)
                    if (userType === 'patient' && navigator.vibrate) {
                        startRingVibration();
                        console.log('Patient: Starting ring vibration - incoming call');
                    }
                    
                    if (userType === 'doctor') {
                        console.log('Doctor: Patient joined! Creating offer IMMEDIATELY');
                        // Create offer immediately instead of waiting for retry
                        setTimeout(() => createOfferIfPossible(), 100);
                    }
                }
                break;
            case 'user-left':
                console.log('User left:', data.user_type);
                if (data.user_type !== userType) {
                    setConnectingStatus('Participant left. Waiting to reconnect...', 'warning');
                    setWaitingState(true);
                    if (userType === 'doctor') {
                        startOfferRetry();
                    }
                }
                break;
            case 'peer-joined':
                console.log('Peer joined event received');
                break;
            case 'peer-left':
                console.log('Peer left event received');
                break;
            case 'call-ended':
                console.log('Call ended by:', data.user_type);
                // Close modal for both users
                handleCallEnded();
                break;
            default:
                console.log('Unknown message type:', data.type);
                break;
        }
    }

    async function initializeWebRTC() {
        console.log('Initializing WebRTC...');
        try {
            console.log('Requesting media devices...');
            localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                    width: { min: 640, ideal: 1280, max: 1920 },
                    height: { min: 480, ideal: 720, max: 1080 },
                    aspectRatio: { ideal: 16/9 },
                    facingMode: 'user',
                    frameRate: { ideal: 30, max: 30 }
                },
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    sampleRate: 48000,
                },
            });
            console.log('Media devices acquired successfully');

            const localVideo = document.getElementById('localVideo');
            localVideo.srcObject = localStream;
            console.log('Local video stream set');

            createPeerConnection();

            localStream.getTracks().forEach((track) => {
                console.log('Adding track to peer connection:', track.kind);
                peerConnection.addTrack(track, localStream);
            });

            console.log('Initializing WebSocket after WebRTC setup...');
            initializeWebSocket();
        } catch (error) {
            console.error('Error accessing media devices:', error);
            console.error('Error name:', error.name);
            console.error('Error message:', error.message);
            alert('Could not access camera or microphone. Please check permissions. Error: ' + error.message);
        }
    }

    function createPeerConnection() {
        console.log('Creating peer connection with ICE servers:', iceServers);
        
        // Clear any queued ICE candidates from previous connection
        iceCandidateQueue = [];
        
        peerConnection = new RTCPeerConnection(iceServers);

        peerConnection.ontrack = function (event) {
            console.log('Remote track received:', event.track.kind);
            if (event.streams && event.streams[0]) {
                console.log('Remote stream received, setting video source');
                remoteStream = event.streams[0];
                const remoteVideo = document.getElementById('remoteVideo');
                remoteVideo.srcObject = remoteStream;
                setWaitingState(false);
                setConnectingStatus('Connected', 'connected');
                
                // Stop ring vibration and vibrate connection confirmation
                stopRingVibration();
                if (navigator.vibrate) {
                    navigator.vibrate([300]); // connection confirmation vibration
                    console.log('Phone vibration - call connected');
                }
                
                if (userType === 'doctor') {
                    stopOfferRetry();
                }
            }
        };

        peerConnection.onicecandidate = function (event) {
            if (event.candidate && websocket && websocket.readyState === WebSocket.OPEN) {
                console.log('Sending ICE candidate');
                websocket.send(
                    JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                    })
                );
            }
        };

        peerConnection.onconnectionstatechange = function () {
            const state = peerConnection.connectionState;
            console.log('Peer connection state changed to:', state);
            if (state === 'connected') {
                setWaitingState(false);
                setConnectingStatus('Connected', 'connected');
                if (userType === 'doctor') {
                    stopOfferRetry();
                }
            }
            if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                setWaitingState(true, 'Waiting for participant to rejoin.');
                setConnectingStatus('Reconnecting media...', 'warning');
                if (userType === 'doctor' && !isEndingCall) {
                    startOfferRetry();
                }
            }
        };
        
        peerConnection.oniceconnectionstatechange = function() {
            console.log('ICE connection state:', peerConnection.iceConnectionState);
        };
    }

    function canCreateOffer() {
        return (
            userType === 'doctor' &&
            peerConnection &&
            websocket &&
            websocket.readyState === WebSocket.OPEN &&
            (peerConnection.signalingState === 'stable' || peerConnection.signalingState === 'have-local-offer') &&
            !isCreatingOffer
        );
    }

    function createOfferIfPossible() {
        if (canCreateOffer()) {
            createOffer();
        }
    }

    function startOfferRetry() {
        if (offerRetryTimer || userType !== 'doctor') return;
        console.log('Doctor: Starting offer retry with 800ms interval for fast connection');
        offerRetryTimer = setInterval(() => {
            if (remoteStream || isEndingCall) {
                stopOfferRetry();
                return;
            }
            if (peerConnection && peerConnection.connectionState !== 'connected') {
                createOfferIfPossible();
            }
        }, 800);  // Fast retry for instant connection
    }

    function stopOfferRetry() {
        if (!offerRetryTimer) return;
        clearInterval(offerRetryTimer);
        offerRetryTimer = null;
    }

    async function createOffer() {
        if (!canCreateOffer()) {
            console.log('Cannot create offer yet, conditions not met');
            return;
        }
        isCreatingOffer = true;
        console.log('Creating offer...');
        try {
            const offer = await peerConnection.createOffer();
            console.log('Offer created:', offer);
            await peerConnection.setLocalDescription(offer);
            console.log('Local description set');

            websocket.send(
                JSON.stringify({
                    type: 'offer',
                    offer: offer,
                })
            );
            console.log('Offer sent via WebSocket');
        } catch (error) {
            console.error('Error creating offer:', error);
        } finally {
            isCreatingOffer = false;
        }
    }

    async function handleOffer(offer) {
        console.log('Handling offer...');
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
            console.log('Remote description (offer) set');
            
            // Process any queued ICE candidates now that remote description is set
            await processQueuedIceCandidates();

            const answer = await peerConnection.createAnswer();
            console.log('Answer created');
            await peerConnection.setLocalDescription(answer);
            console.log('Local description (answer) set');

            websocket.send(
                JSON.stringify({
                    type: 'answer',
                    answer: answer,
                })
            );
            console.log('Answer sent via WebSocket');
        } catch (error) {
            console.error('Error handling offer:', error);
        }
    }

    async function handleAnswer(answer) {
        console.log('Handling answer...');
        try {
            await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
            console.log('Remote description (answer) set successfully');
            
            // Process any queued ICE candidates now that remote description is set
            await processQueuedIceCandidates();
        } catch (error) {
            console.error('Error handling answer:', error);
        }
    }

    async function handleIceCandidate(candidate) {
        try {
            if (!peerConnection) {
                console.log('PeerConnection not ready, queueing ICE candidate');
                iceCandidateQueue.push(candidate);
                return;
            }
            
            // Check if remote description is set
            if (!peerConnection.remoteDescription || !peerConnection.remoteDescription.type) {
                console.log('Remote description not set yet, queueing ICE candidate');
                iceCandidateQueue.push(candidate);
                return;
            }
            
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log('ICE candidate added successfully');
        } catch (error) {
            console.error('Error adding ICE candidate:', error);
        }
    }
    
    async function processQueuedIceCandidates() {
        console.log(`Processing ${iceCandidateQueue.length} queued ICE candidates`);
        while (iceCandidateQueue.length > 0) {
            const candidate = iceCandidateQueue.shift();
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                console.log('Queued ICE candidate added successfully');
            } catch (error) {
                console.error('Error adding queued ICE candidate:', error);
            }
        }
    }

    function toggleMute() {
        if (!localStream) return;

        isMuted = !isMuted;
        localStream.getAudioTracks().forEach((track) => {
            track.enabled = !isMuted;
        });

        const muteBtn = document.getElementById('muteBtn');
        muteBtn.classList.toggle('is-off', isMuted);
    }

    function toggleVideo() {
        if (!localStream) return;

        isVideoOff = !isVideoOff;
        localStream.getVideoTracks().forEach((track) => {
            track.enabled = !isVideoOff;
        });

        const videoBtn = document.getElementById('videoBtn');
        videoBtn.classList.toggle('is-off', isVideoOff);
    }

    function endCall() {
        isEndingCall = true;

        if (websocket && websocket.readyState === WebSocket.OPEN) {
            // Send call-ended to close both users' modals
            websocket.send(
                JSON.stringify({
                    type: 'call-ended',
                    user_type: userType,
                    user_name: userType === 'doctor' ? 'Doctor' : 'Patient',
                })
            );
        }

        // Clean up local resources
        cleanupCallResources();

        stopOfferRetry();
        
        // Close popup window immediately (if opened via popup)
        if (window.opener) {
            window.close();
        } else {
            // Fallback: redirect to prior screen if not opened as popup
            const encodedReturnTo = encodeURIComponent(returnTo || '/accounts/dashboard/');
            window.location.href = `/medical/appointments/${appointmentId}/video-call/end/?return_to=${encodedReturnTo}`;
        }
    }
    
    function cleanupCallResources() {
        stopRingVibration();
        stopOfferRetry();
        
        if (localStream) {
            localStream.getTracks().forEach((track) => track.stop());
        }

        if (peerConnection) {
            peerConnection.close();
        }

        if (websocket) {
            websocket.close();
        }
    }
    
    function handleCallEnded() {
        console.log('Handling call ended - closing modal for both users');
        isEndingCall = true;
        
        // Clean up local resources
        cleanupCallResources();
        
        stopOfferRetry();
        
        // Close the modal and return to previous page
        const encodedReturnTo = encodeURIComponent(returnTo || '/accounts/dashboard/');
        window.location.href = `/medical/appointments/${appointmentId}/video-call/end/?return_to=${encodedReturnTo}`;
    }

    window.addEventListener('beforeunload', function () {
        stopOfferRetry();
        if (websocket) {
            websocket.close();
        }
        if (peerConnection) {
            peerConnection.close();
        }
    });

    document.addEventListener('DOMContentLoaded', function () {
        if (!roomId) {
            setWaitingState(true, 'Call room is not ready yet.');
            setConnectingStatus('Room setup incomplete.', 'warning');
            return;
        }

        setConnectingStatus('Connecting...', 'connecting');

        const remoteVideo = document.getElementById('remoteVideo');
        remoteVideo.addEventListener('playing', function () {
            setWaitingState(false);
            setConnectingStatus('Connected', 'connected');
        });

        initializeWebRTC();
    });
</script>
{% endblock %}
